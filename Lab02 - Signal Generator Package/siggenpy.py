# -*- coding: utf-8 -*-
"""siggenpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EKL25dKplFNGKLD1MA6XmB_wzvPSKMOv
"""

import numpy as np
import scipy.signal as sig
from matplotlib import pyplot as plt
import seaborn as sns

class discrete_time:
  def __init__ (self, min, max):
    self.min = min
    self.max = max

  def disc_plot(x, y, title, func_name='f[n]'):
    plt.figure(figsize=(8,5))
    plt.title(title)
    plt.xlabel("n")
    plt.ylabel(func_name)
    plt.stem(x,y,use_line_collection=True)
    plt.grid()
    return plt.show()

  def unit_impulse(self):
    N = np.arange(self.min, self.max+1)
    delta_sig = sig.unit_impulse(N.shape, idx='mid')
    return delta_sig
  
  def unit_step(self):
    N = np.arange(self.min, self.max+1)
    unit_step = np.ones(N.shape)
    unit_step[N<0]=0
    return unit_step

  def ramp_signal(self):
    N = np.arange(self.min, self.max+1)
    ramp_step = N * discrete_time.unit_step(self)
    return ramp_step

  def exponential_decay(self, alpha):
    N = np.arange(self.min, self.max+1)
    unit_step = np.ones(N.shape)
    unit_step[N<0]=0
    exp_decay = (alpha**N) * unit_step
    return exp_decay

  def exponential_growth(self, alpha):
    N = np.arange(self.min, self.max+1)
    unit_step = np.ones(N.shape)
    unit_step[N<0]=0
    exp_growth = (N**alpha) * unit_step
    return exp_growth

  def leaky_ReLU(self, alpha):
    N = np.arange(self.min, self.max)
    unit_step = np.ones(N.shape)
    leaky_relu = N * unit_step
    leaky_relu[N<0] *= alpha
    return leaky_relu
  
  def ELU_signal(self, alpha):
    N = np.arange(self.min, self.max)
    unit_step = np.ones(N.shape)
    elu = N * unit_step
    elu[N<0]=alpha
    return elu
  
  def sigmoid_signal(self):
    x = np.arange(self.min, self.max+1)
    s = 1 / (1 + np.exp((-x)))
    return s

  def generate_signal(self, signal, alpha=0.01):
    if signal == 'impulse':
      return discrete_time.disc_plot(np.arange(self.min, self.max+1), discrete_time.unit_impulse(self), 'Impulse Signal')
    elif signal == 'unit-step':
      return discrete_time.disc_plot(np.arange(self.min, self.max+1), discrete_time.unit_step(self), 'Unit-Step Signal')
    elif signal == 'ramp':
      return discrete_time.disc_plot(np.arange(self.min, self.max+1), discrete_time.ramp_signal(self), 'Ramp Signal')
    elif signal == 'decay':
      return discrete_time.disc_plot(np.arange(self.min, self.max+1), discrete_time.exponential_decay(self, alpha), 'Exponential Decay Signal')
    elif signal == 'growth':
      return discrete_time.disc_plot(np.arange(self.min, self.max+1), discrete_time.exponential_growth(self, alpha), 'Exponential Growth Signal')
    elif signal == 'leaky':
      return discrete_time.disc_plot(np.arange(self.min, self.max), discrete_time.leaky_ReLU(self, alpha), 'Leaky Signal')
    elif signal == 'elu':
      return discrete_time.disc_plot(np.arange(self.min, self.max), discrete_time.ELU_signal(self, alpha), 'ELU Signal')
    elif signal == 'sigmoid':
      return discrete_time.disc_plot(np.arange(self.min, self.max+1), discrete_time.sigmoid_signal(self), 'Sigmoid Signal')
    else:
      print("Invalid signal input")